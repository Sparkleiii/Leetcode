# MySQL索引
## 索引

### 什么是索引
   理解为书籍的目录，字典的检索部分
### 数据库索引类型
1. 聚集索引
   表中行的物理顺序和索引顺序相同，InnoDB引擎使用聚集索引。聚集索引类似于电话簿，后者按姓氏排列数据。由于聚集索引规定数据在表中的物理存储顺序，因此**一个表只能包含一个聚集索引**。
2. 非聚集索引
   索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同。索引是通过二叉树的数据结构来描述的，聚集索引的叶子节点就是数据节点。

3. 组合索引
   就是好几个字段组成的索引，称为联合索引。例如
```mysql
key 'idx_age_name_sex' ('age','name','sex')
```

​	   组合索引遵从最左前缀原则，何为最左前缀原则？

```mysql
A:select * from student where age = 16 and name = '小张'
B:select * from student where name = '小张' and sex = '男'
C:select * from student where name = '小张' and sex = '男' and age = 18
D:select * from student where age > 20 and name = '小张'
E:select * from student where age != 15 and name = '小张'
```

 A查询语句遵从最左前缀原则，age是在最左边，所以A查询语句会使用组合索引；

B查询语句在where后的第一个查询字段为'name'，不遵从最左前缀袁泽，因此B查询语句不会使用组合索引。

C查询语句虽然从name开始，但是有索引最左边的age，**mysql内部会自动转化**成where age = '18' and name = '小张'  and sex = '男' 这种，所以还是遵从最左前缀原则；

 D这个是因为age>20是范围，**范围字段会结束索引对范围后面索引字段的使用**，所以只走了age这个索引；

 E这个虽然遵循最左匹配原则，但是不走索引，因为**!= 不走索引**；

总结：从最左边的一个查询字段开始匹配，一旦不匹配则后续查询字段将不再使用索引。


### 哪些情况下回不适用索引
 表student中两个字段age,name加了索引

```mysql
key  'idx_age' ('age'),key 'idx_name'('name')
```

1. Like这种就是%在前面的不走索引，在后面的走索引

```mysql
A:select * from student where 'name' like '王%'
B:select * from student where 'name' like '%小'
```

 A走索引，B不走索引

2. 用索引列进行计算的，不走索引

```mysql
A:select * from student where age = 10+8
B:select * from student where age + 8= 18
```

 A走索引，B不走索引

3. 对索引列用函数了，不走索引

```mysql
A:select * from student where concat('name','哈') ='王哈哈';
B:select * from student where name = concat('王哈','哈');
```

 A不走索引，B走索引

4.  索引列用了!= 不走索引,如下：

```mysql
select * from student where age != 18
```

### B+树

##### 特点

![img](http://img.mp.sohu.com/upload/20170713/358025867be14bb99bf8806b98e774d9_th.png)

1. 首先，每一个父节点的元素都出现在子节点中，是子节点的最大(或最小)元素。每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。（和B树不同，B树的非叶子结点也会存储数据，而B+树所有的数据都存储在叶子结点中）。

2. 所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。

3. 所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。

   ![img](https://www.eimg.top/images/2020/01/05/05a53d40f199e89b2b99aec177023ae7.jpg)

   <center>图为B-树</center>

#### 优势

1. 单一节点存储更多的元素，使得查询的IO次数更少。

2. 所有查询都要查找到叶子节点，查询性能稳定。

3. 所有叶子节点形成有序链表，便于范围查询。

### 索引在磁盘上是如何存储的

1. 聚集索引
	
	![img](https://img2018.cnblogs.com/blog/1724040/201907/1724040-20190702132817870-805725869.png)
	
	 聚集索引叶子结点存储是表里面的所有行数据；
	
	 每个数据页在不同的磁盘上面；
	
	如果要查找id=5的数据，那么先把磁盘0读入内存，然后用二分法查找id=5的数在3和6之间，然后通过指针p1查找到磁盘2的地址，然后将磁盘2读入内存中，用二分查找方式查找到id=5的数据。
	
2. 非聚集索引

   ![img](https://img2018.cnblogs.com/blog/1724040/201907/1724040-20190702133841357-2122435579.png)

   叶子结点存储的是**聚集索引键**，而不存储表里面所有的行数据，所以在查找的时候，只能查找到聚集索引键，再通过聚集索引去表里面查找到数据。

   如果要查找到name = 小徐，首先将磁盘0加载到内存中，然后用二分查找的方法查到在指针p1所指的地址上，然后通过指针p1所指的地址可知道在磁盘2上面，然后通过二分查找法得知小徐id=4；然后通过id=4查找出真正行数据，就查找出name=小徐的数据了。

### 聚集索引与非聚集索引的不同

实际上，您可以把索引理解为一种特殊的目录。微软的SQL SERVER提供了两种索引：聚集索引（clustered index，也称聚类索引、簇集索引）和非聚集索引（nonclustered index，也称非聚类索引、非簇集索引）。下面，我们举例来说明一下聚集索引和非聚集索引的区别：
   其实，我们的汉语字典的正文本身就是一个聚集索引。字典的正文部分本身就是一个目录，您不需要再去查其他目录来找到您需要找的内容。我们把这种正文内容本身就是一种按照一定规则排列的目录称为“聚集索引”。
   如果您认识某个字，您可以快速地从自动中查到这个字。但您也可能会遇到您不认识的字，不知道它的发音，这时候，您就不能按照刚才的方法找到您要查的字，而需要去根据“偏旁部首”查到您要找的字，然后根据这个字后的页码直接翻到某页来找到您要找的字。但您结合“部首目录”和“检字表”而查到的字的排序并不是真正的正文的排序方法，比如您查“张”字，我们可以看到在查部首之后的检字表中“张”的页码是672页，检字表中“张”的上面是“驰”字，但页码却是63页，“张”的下面是“弩”字，页面是390页。很显然，这些字并不是真正的分别位于“张”字的上下方，现在您看到的连续的“驰、张、弩”三字实际上就是他们在非聚集索引中的排序，是字典正文中的字在非聚集索引中的映射。我们可以通过这种方式来找到您所需要的字，但它需要两个过程，先找到目录中的结果，然后再翻到您所需要的页码。我们把这种目录纯粹是目录，正文纯粹是正文的排序方式称为“非聚集索引”。
   通过以上例子，我们可以理解到什么是“聚集索引”和“非聚集索引”。进一步引申一下，我们可以很容易的理解：每个表只能有一个聚集索引，因为正文只能按照一种方法进行排序。
** 聚集索引的叶子结点存储的是数据文件，而非聚集索引的叶子节点存的是数据文件的地址指针。**